package com.kaching123.tcr.service;

import android.accounts.AccountsException;
import android.content.Context;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.util.concurrent.TimeUnit;

import com.kaching123.tcr.Logger;
import com.kaching123.tcr.TcrApplication;
import com.kaching123.tcr.commands.rest.sync.GetPagedArrayResponse;
import com.kaching123.tcr.commands.rest.sync.SyncApi;
import com.kaching123.tcr.commands.rest.sync.SyncGetRequestBuilder;
import com.kaching123.tcr.commands.rest.sync.SyncUploadRequestBuilder;
import com.kaching123.tcr.jdbc.JdbcFactory;
import com.kaching123.tcr.jdbc.converters.JdbcConverter;
import com.kaching123.tcr.model.EmployeeModel;
import com.kaching123.tcr.service.response.SyncResponseHandler.HandlerResult;
import com.kaching123.tcr.service.response.SyncSingleResponseHandler;
import com.kaching123.tcr.store.ShopStore;
import com.kaching123.tcr.store.ShopStore.CashDrawerMovementTable;
import com.kaching123.tcr.store.ShopStore.CategoryTable;
import com.kaching123.tcr.store.ShopStore.CestTable;
import com.kaching123.tcr.store.ShopStore.ComposerTable;
import com.kaching123.tcr.store.ShopStore.CreditReceiptTable;
import com.kaching123.tcr.store.ShopStore.CustomerTable;
import com.kaching123.tcr.store.ShopStore.DepartmentTable;
import com.kaching123.tcr.store.ShopStore.EmployeeCommissionsTable;
import com.kaching123.tcr.store.ShopStore.EmployeePermissionTable;
import com.kaching123.tcr.store.ShopStore.EmployeeTable;
import com.kaching123.tcr.store.ShopStore.EmployeeTimesheetTable;
import com.kaching123.tcr.store.ShopStore.EmployeeTipsTable;
import com.kaching123.tcr.store.ShopStore.ItemMatrixTable;
import com.kaching123.tcr.store.ShopStore.ItemMovementTable;
import com.kaching123.tcr.store.ShopStore.ItemTable;
import com.kaching123.tcr.store.ShopStore.ModifierGroupTable;
import com.kaching123.tcr.store.ShopStore.ModifierTable;
import com.kaching123.tcr.store.ShopStore.MunicipalityTable;
import com.kaching123.tcr.store.ShopStore.NCMFavouritesTable;
import com.kaching123.tcr.store.ShopStore.NCMItemTable;
import com.kaching123.tcr.store.ShopStore.PaymentServiceProviderTable;
import com.kaching123.tcr.store.ShopStore.PaymentTransactionTable;
import com.kaching123.tcr.store.ShopStore.PisCofinsTable;
import com.kaching123.tcr.store.ShopStore.PrinterAliasTable;
import com.kaching123.tcr.store.ShopStore.RegisterTable;
import com.kaching123.tcr.store.ShopStore.SaleAddonTable;
import com.kaching123.tcr.store.ShopStore.SaleComposerTable;
import com.kaching123.tcr.store.ShopStore.SaleItemTable;
import com.kaching123.tcr.store.ShopStore.SaleOrderTable;
import com.kaching123.tcr.store.ShopStore.ShiftTable;
import com.kaching123.tcr.store.ShopStore.TaxGroupTable;
import com.kaching123.tcr.store.ShopStore.UnitLabelTable;
import com.kaching123.tcr.store.ShopStore.UnitTable;
import com.kaching123.tcr.store.ShopStore.VariantItemTable;
import com.kaching123.tcr.store.ShopStore.VariantSubItemTable;
import retrofit.RetrofitError;

public class SyncCommandOldBR extends SyncCommandBaseBR {

    protected String getShopId() {
        return String.valueOf(getApp().getShopId());
    }

    private static final int PAGE_ROWS = 1800;

    private static final int FINALIZE_SYNC_RETRIES = 3;

    private boolean serverHasBeenUpdated;
    private long serverLastTimestamp;

    public SyncCommandOldBR(Context service, boolean isManual) {
        super();
        this.service = service;
        this.isManual = isManual;
    }

    protected TcrApplication getApp() {
        return (TcrApplication) service.getApplicationContext();
    }


    @Override
    protected int syncNowInner(final EmployeeModel employee) throws SyncCommand.SyncException, SyncCommand.DBVersionCheckException, SyncCommand.SyncInconsistentException, SyncCommand.SyncLockedException, SyncInterruptedException, AccountsException, JSONException, IOException {

        if (getApp().isTrainingMode()) {
            throw new AccountsException();
        }
        checkForceCancel(null);
        Logger.w("SYNC IN PROGRESS");

        Integer salesHistoryLimit = syncShopInfo(employee);
        if (salesHistoryLimit == null) {
            Logger.w("SyncCommand.syncNowInner(): sales history limit is not set yet");
        }

        int count = 0;
        shopOpenHelper = getApp().getSyncOpenHelper();

        SyncApi api = getApp().getRestAdapter().create(SyncApi.class);
        Logger.d("[SYNC HISTORY]SyncCommand: acquiring history lock");
        getApp().lockOnSalesHistory();
        checkForceCancel(null);

        try {
            Logger.d("[SYNC HISTORY]SyncCommand: history lock acquired");
            checkIsLoadingOldOrders();

            serverLastTimestamp = getServerCurrentTimestamp(api, employee);
            Long minUpdateTime = salesHistoryLimit == null ? null : serverLastTimestamp - TimeUnit.DAYS.toMillis(salesHistoryLimit);


            Integer oldSalesHistoryLimit = getApp().getSalesHistoryLimit();
            if (oldSalesHistoryLimit != null && salesHistoryLimit != null && salesHistoryLimit > oldSalesHistoryLimit) {
                Long lastSuccessfulSyncTime = getApp().getLastSuccessfulSyncTime();
                long oldMinUpdateTime = serverLastTimestamp - TimeUnit.DAYS.toMillis(oldSalesHistoryLimit);
                if (lastSuccessfulSyncTime != null && lastSuccessfulSyncTime < oldMinUpdateTime) {
                    getApp().setLastSuccessfulSyncTime(null);
                }
            }
            checkForceCancel(null);
            getApp().setSalesHistoryLimit(salesHistoryLimit);

            if (oldSalesHistoryLimit == null && salesHistoryLimit != null) {
                Logger.w("SyncCommand.syncNowInner(): sales history limit first set, notifying");
                notifySyncGep();
            }

            int retriesCount = FINALIZE_SYNC_RETRIES;

            do {
                checkIsLoadingOldOrders();

                if (retriesCount != FINALIZE_SYNC_RETRIES) {
                    serverLastTimestamp = getServerCurrentTimestamp(api, employee);
                    checkIsLoadingOldOrders();
                }

                Logger.d("SyncCommand.syncNowInner(): attempt #" + (FINALIZE_SYNC_RETRIES - retriesCount + 1) + "; serverLastTimestamp: " + serverLastTimestamp + "; minUpdateTime: " + minUpdateTime);
                serverHasBeenUpdated = false;

                syncLocations(employee);
                checkForceCancel(null);

                count += syncSingleTable2(service, api, MunicipalityTable.TABLE_NAME, MunicipalityTable.ID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, ComposerTable.TABLE_NAME, ComposerTable.ID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, UnitLabelTable.TABLE_NAME, UnitLabelTable.GUID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, PisCofinsTable.TABLE_NAME, PisCofinsTable.ID, employee, serverLastTimestamp);

                count += syncSingleTable2(service, api, RegisterTable.TABLE_NAME, RegisterTable.ID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, PrinterAliasTable.TABLE_NAME, PrinterAliasTable.GUID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, CustomerTable.TABLE_NAME, CustomerTable.GUID, employee, serverLastTimestamp);

                //employee
                count += syncSingleTable2(service, api, EmployeeTable.TABLE_NAME, EmployeeTable.GUID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, EmployeePermissionTable.TABLE_NAME, EmployeePermissionTable.PERMISSION_ID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, EmployeeTimesheetTable.TABLE_NAME, EmployeeTimesheetTable.GUID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, ShiftTable.TABLE_NAME, ShiftTable.GUID, employee, serverLastTimestamp);

                count += syncSingleTable2(service, api, CashDrawerMovementTable.TABLE_NAME, CashDrawerMovementTable.GUID, employee, serverLastTimestamp);

                checkForceCancel(null);

                //inventory
                count += syncSingleTable2(service, api, NCMItemTable.TABLE_NAME, NCMItemTable.ID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, CestTable.TABLE_NAME, CestTable.ID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, NCMFavouritesTable.TABLE_NAME, NCMFavouritesTable.ID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, TaxGroupTable.TABLE_NAME, TaxGroupTable.GUID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, DepartmentTable.TABLE_NAME, DepartmentTable.GUID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, CategoryTable.TABLE_NAME, CategoryTable.GUID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, ItemTable.TABLE_NAME, ItemTable.GUID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, ModifierGroupTable.TABLE_NAME, ModifierGroupTable.GUID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, ModifierTable.TABLE_NAME, ModifierTable.MODIFIER_GUID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, VariantItemTable.TABLE_NAME, VariantItemTable.GUID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, VariantSubItemTable.TABLE_NAME, VariantSubItemTable.GUID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, ItemMatrixTable.TABLE_NAME, ItemMatrixTable.GUID, employee, serverLastTimestamp);

                //between iterations shouldn't be any gaps
                boolean firstIteration = retriesCount == FINALIZE_SYNC_RETRIES;
                Long lastSuccessfulSyncTime = getApp().getLastSuccessfulSyncTime();
                boolean lastSyncStillActual = salesHistoryLimit == null || (lastSuccessfulSyncTime != null && lastSuccessfulSyncTime >= minUpdateTime);

                checkIsLoadingOldOrders();

                count += syncSingleTable2(service, api, ItemMovementTable.TABLE_NAME, ItemMovementTable.GUID, employee, serverLastTimestamp, minUpdateTime, true);

                //sale

                boolean isSalesSyncGep = false;
                if (firstIteration && !lastSyncStillActual) {
                    isSalesSyncGep = checkIsSalesSyncGep(shopOpenHelper, minUpdateTime);
                }
                boolean isFirstSync = false;
                if (isSalesSyncGep) {
                    isFirstSync = isFirstSync(service);

                    getApp().setSalesSyncGapOccurred(true);
                }
                checkIsLoadingOldOrders();

                if (salesHistoryLimit != null) {
                    syncOldActiveOrders(service, api, employee, minUpdateTime);
                    checkIsLoadingOldOrders();
                }
                checkForceCancel(null);

                count += syncTableWithChildren2(service, api, SaleOrderTable.TABLE_NAME, SaleOrderTable.GUID, SaleOrderTable.PARENT_ID, employee, serverLastTimestamp, minUpdateTime, false);
                count += syncTableWithChildren2(service, api, SaleItemTable.TABLE_NAME, SaleItemTable.SALE_ITEM_GUID, SaleItemTable.PARENT_GUID, employee, serverLastTimestamp, minUpdateTime, false);
                count += syncSingleTable2(service, api, SaleAddonTable.TABLE_NAME, SaleAddonTable.GUID, employee, serverLastTimestamp, minUpdateTime, false);
                count += syncSingleTable2(service, api, SaleComposerTable.TABLE_NAME, SaleComposerTable.ID, employee, serverLastTimestamp, minUpdateTime, false);
                count += syncTableWithChildren2(service, api, PaymentTransactionTable.TABLE_NAME, PaymentTransactionTable.GUID, PaymentTransactionTable.PARENT_GUID, employee, serverLastTimestamp, minUpdateTime, false);
                count += syncSingleTable2(service, api, CreditReceiptTable.TABLE_NAME, CreditReceiptTable.GUID, employee, serverLastTimestamp);
                count += syncTableWithChildren2(service, api, EmployeeTipsTable.TABLE_NAME, EmployeeTipsTable.GUID, EmployeeTipsTable.PARENT_GUID, employee, serverLastTimestamp, minUpdateTime, false);
                count += syncSingleTable2(service, api, EmployeeCommissionsTable.TABLE_NAME, EmployeeCommissionsTable.GUID, employee, serverLastTimestamp, minUpdateTime, false);

                //inventory depended from sale
                count += syncSingleTable2(service, api, UnitTable.TABLE_NAME, UnitTable.ID, employee, serverLastTimestamp, minUpdateTime, true, isSalesSyncGep, isFirstSync);
                //end

                count += syncSingleTable2(service, api, PaymentServiceProviderTable.TABLE_NAME, PaymentServiceProviderTable.ID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, ShopStore.CfopReturnMappingTable.TABLE_NAME, ShopStore.CfopReturnMappingTable.ID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, ShopStore.CardBrandTable.TABLE_NAME, ShopStore.CardBrandTable.ID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, ShopStore.TableOrderTable.TABLE_NAME, ShopStore.TableOrderTable.GUID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, ShopStore.CustomerOrderTable.TABLE_NAME, ShopStore.CustomerOrderTable.GUID, employee, serverLastTimestamp);
                count += syncSingleTable2(service, api, ShopStore.ShopModuleTable.TABLE_NAME, ShopStore.ShopModuleTable.ID, employee, serverLastTimestamp);

                checkForceCancel(null);
            } while (serverHasBeenUpdated && --retriesCount > 0);

            if (serverHasBeenUpdated) {
                Logger.e("SyncCommand failed, couldn't finalize sync, server's data has been modified");
                throw new SyncInconsistentException();
            }

            //check that sales limit setting hasn't changed
            if (salesHistoryLimit != null) {
                checkServerSalesHistoryLimit(api, employee, salesHistoryLimit);
            }

            //write data from extra db to main db on success, in transaction, making rows alive
            executeHook(EmployeePermissionTable.URI_CONTENT, EmployeePermissionTable.USER_GUID, getApp().getOperatorGuid(), employeePermissionsHookListener);
            employeePermissionsHookListener.onFinish();

            //mark DB as synced
            markRecordsAsLive(service);

            getApp().setLastSuccessfulSyncTime(serverLastTimestamp);

            if (getApp().isSalesSyncGapOccurred()) {
                notifySyncGep();
                getApp().setSalesSyncGapOccurred(false);
            }
        } finally {
            Logger.d("[SYNC HISTORY]SyncCommand: releasing history lock");
            getApp().unlockOnSalesHistory();
            Logger.d("[SYNC HISTORY]SyncCommand: history lock released");

        }
        syncShopInfo(employee);

        checkForceCancel(null);

        return count;
    }

    private int syncTableWithChildren2(Context context, SyncApi api, String localTable, String guidColumn, String parentIdColumn, EmployeeModel employeeModel, long serverLastUpdateTime, Long minUpdateTime, boolean fillHistoryGep) throws SyncException, SyncLockedException, SyncInterruptedException {
        int count = syncSingleTable2(context, api, localTable, guidColumn, employeeModel, true, parentIdColumn, false, serverLastUpdateTime, minUpdateTime, true, fillHistoryGep, false, false);
        count += syncSingleTable2(context, api, localTable, guidColumn, employeeModel, true, parentIdColumn, true, serverLastUpdateTime, minUpdateTime, true, fillHistoryGep, false, false);
        return count;
    }

    private int syncSingleTable2(Context context, SyncApi api, String localTable, String guidColumn, EmployeeModel employeeModel, long serverLastUpdateTime) throws SyncException, SyncLockedException, SyncInterruptedException {
        return syncSingleTable2(context, api, localTable, guidColumn, employeeModel, false, null, false, serverLastUpdateTime, 0L, false, false, false, false);
    }

    private int syncSingleTable2(Context context, SyncApi api, String localTable, String guidColumn, EmployeeModel employeeModel, long serverLastUpdateTime, Long minUpdateTime, boolean fillHistoryGep) throws SyncException, SyncLockedException, SyncInterruptedException {
        return syncSingleTable2(context, api, localTable, guidColumn, employeeModel, false, null, false, serverLastUpdateTime, minUpdateTime, true, fillHistoryGep, false, false);
    }

    private int syncSingleTable2(Context context, SyncApi api, String localTable, String guidColumn, EmployeeModel employeeModel, long serverLastUpdateTime, Long minUpdateTime, boolean fillHistoryGep, boolean isSyncGap, boolean isFirstSync) throws SyncException, SyncLockedException, SyncInterruptedException {
        return syncSingleTable2(context, api, localTable, guidColumn, employeeModel, false, null, false, serverLastUpdateTime, minUpdateTime, true, fillHistoryGep, isSyncGap, isFirstSync);
    }

    private int syncSingleTable2(Context context, SyncApi api, String localTable, String guidColumn, EmployeeModel employeeModel,
                                 boolean supportParentChildRelations,
                                 String parentIdColumn,
                                 boolean isChild,
                                 long serverLastUpdateTime,
                                 Long minUpdateTime,
                                 boolean limitHistory,
                                 boolean fillHistoryGep,
                                 boolean isSyncGap,
                                 boolean isFirstSync) throws SyncException, SyncLockedException, SyncInterruptedException {

        OfflineCommandsService.fireEvent(context, localTable);
        TcrApplication app = TcrApplication.get();

        SyncSingleResponseHandler handler = new SyncSingleResponseHandler(
                shopOpenHelper,
                JdbcFactory.getConverter(localTable),
                localTable,
                serverLastUpdateTime
        );

        boolean hasNext = true;
        int size = 0;
        while (hasNext) {
            checkForceCancel(null);

            MaxUpdateTime updateTime = getMaxTimeSingleTable(context, shopOpenHelper, localTable, guidColumn, parentIdColumn, isChild);

            if (limitHistory && minUpdateTime != null) {
                if (!fillHistoryGep && (updateTime == null || updateTime.time < minUpdateTime)) {
                    updateTime = new MaxUpdateTime(minUpdateTime, null);
                }
            }
            JdbcConverter converter = JdbcFactory.getConverter(localTable);
            try {
                int moreSize = processResponse(getResponse(api, employeeModel, localTable, supportParentChildRelations, isChild, app, minUpdateTime, updateTime, converter,
                        fillHistoryGep, isSyncGap, isFirstSync), localTable, handler, 0);
                hasNext = moreSize > 0;
                size += moreSize;

            } catch (JSONException e) {
                e.printStackTrace();

                Logger.e("sync table " + localTable + " exception", e);
                throw new SyncException(localTable);
            }

            checkIsLoadingOldOrders();
        }
        return size;
    }

    private int processResponse(GetPagedArrayResponse resp, String localTable, SyncSingleResponseHandler handler, int retry) throws SyncLockedException, SyncException {
        HandlerResult handlerResult = null;
        try {
            Logger.d("Resp = %s", resp);
            if (resp != null && resp.isSyncLockedError()) {
                throw new SyncLockedException();
            }
            if (resp == null || !resp.isSuccess()) {
                throw new SyncException(localTable);
            }

            String parentIdColumn = getIdColumnAndParentId(localTable)[1];
            boolean hasChildren = hasChildren(parentIdColumn);
            boolean staticTable = isStaticTable(localTable);

            handlerResult = handler.handleResponse(resp, hasChildren, staticTable, parentIdColumn);
            if (handlerResult.dataCount > 0) {
                OfflineCommandsService.fireEvent(service, localTable, 0, 0);
            }
            if (handlerResult.serverHasBeenUpdated) {
                Logger.w("SyncCommand.syncSingleTable2(): server data has been updated; table: " + localTable);
                serverHasBeenUpdated = true;
            }

            return handlerResult.dataCount;

        } catch (RuntimeException e) {
            if (handlerResult == null || !checkForeignKey(service, null, null, localTable, handlerResult.values)){
                throw e;
            } else if (retry <= 3){
                return processResponse(resp, localTable, handler, retry + 1);
            }

        } catch (SyncLockedException | SyncException e) {
            throw e;

        } catch (Exception e) {
            Logger.e("sync table " + localTable + " exception", e);
            throw new SyncException(localTable);
        }
        return 0;
    }

    private GetPagedArrayResponse getResponse(SyncApi api,
                                              EmployeeModel employeeModel,
                                              String localTable,
                                              boolean supportParentChildRelations,
                                              boolean isChild,
                                              TcrApplication app,
                                              Long minUpdateTime,
                                              MaxUpdateTime updateTime,
                                              JdbcConverter converter,
                                              boolean fillHistoryGep,
                                              boolean isSyncGap,
                                              boolean isFirstSync) throws JSONException, SyncException, SyncInterruptedException {
        JSONObject credentials = SyncUploadRequestBuilder.getReqCredentials(employeeModel, app);

        if (fillHistoryGep && minUpdateTime != null
                && (updateTime == null || updateTime.time < minUpdateTime)) {
            if (UnitTable.TABLE_NAME.equals(localTable)) {
                if (!isSyncGap || isFirstSync)
                    return makeUnitsRequest(api, app.emailApiKey,
                            credentials,
                            SyncGetRequestBuilder.getHistoryLimitRequest(
                                    minUpdateTime,
                                    updateTime,
                                    converter.getGuidColumn(),
                                    PAGE_ROWS));
            } else if (ItemMovementTable.TABLE_NAME.equals(localTable)) {
                return makeMovementsRequest(api, app.emailApiKey,
                        credentials,
                        SyncGetRequestBuilder.getHistoryLimitRequest(
                                minUpdateTime,
                                updateTime,
                                converter.getGuidColumn(),
                                PAGE_ROWS));
            } else {
                throw new IllegalArgumentException("fill history limit gap feature is not supported for table: " + localTable);
            }
        }

        JSONObject requestBody = SyncGetRequestBuilder.getRequestFull(
                converter.getTableName(),
                updateTime,
                converter.getGuidColumn(),
                supportParentChildRelations ? converter.getParentGuidColumn() : null,
                isChild,
                PAGE_ROWS);

        if (NCMItemTable.TABLE_NAME.equals(localTable)){
            return makeNCMRequest(api, app.emailApiKey, credentials, requestBody);
        }

        return makeRequest(api, app.emailApiKey, credentials, requestBody);
    }

    private GetPagedArrayResponse makeRequest(SyncApi api, String apiKey, JSONObject credentials, JSONObject entity) throws JSONException, SyncException, SyncInterruptedException {
       int retry = 0;
        while (retry++ < 5) {
            checkForceCancel(null);

            try {
                return api.download(getShopId(), apiKey, credentials, entity);
            } catch (RetrofitError e) {
                Logger.e("attempt: " + retry, e);
            }
        }
        throw new SyncException();
    }

    private GetPagedArrayResponse makeUnitsRequest(SyncApi api, String apiKey, JSONObject credentials, JSONObject entity) throws JSONException, SyncException, SyncInterruptedException {
        int retry = 0;
        while (retry++ < 5) {
            checkForceCancel(null);

            try {
                return api.downloadUnitsLimited(getShopId(), apiKey, credentials, entity);
            } catch (RetrofitError e) {
                Logger.e("attempt: " + retry, e);
            }
        }
        throw new SyncException();
    }

    private GetPagedArrayResponse makeMovementsRequest(SyncApi api, String apiKey, JSONObject credentials, JSONObject entity) throws JSONException, SyncException, SyncInterruptedException {
       int retry = 0;
        while (retry++ < 5) {
            checkForceCancel(null);

            try {
                return api.downloadMovementGroups(getShopId(), apiKey, credentials, entity);
            } catch (RetrofitError e) {
                Logger.e("attempt: " + retry, e);
            }
        }
        throw new SyncException();
    }

    private GetPagedArrayResponse makeNCMRequest(SyncApi api, String apiKey, JSONObject credentials, JSONObject entity) throws JSONException, SyncException, SyncInterruptedException {
        int retry = 0;
        while (retry++ < 5) {
            checkForceCancel(null);

            try {
                return api.downloadNCM(getShopId(), apiKey, credentials, entity);
            } catch (RetrofitError e) {
                Logger.e("attempt: " + retry, e);
            }
        }
        throw new SyncException();
    }

    public boolean downloadDataTable(String localTable, String guid) {
        try {
            JSONObject request = new JSONObject();
            request.put("table", JdbcFactory.getConverter(localTable).getTableName());
            request.put("where", new JSONObject("{'" + JdbcFactory.getConverter(localTable).getGuidColumn() + "': '" + guid + "'}"));
            request.put("from", "");
            request.put("limit", 1);

            SyncApi api = getApp().getRestAdapter().create(SyncApi.class);

            JSONObject credentials = SyncUploadRequestBuilder.getReqCredentials(employeeModel, getApp());

            SyncSingleResponseHandler handler = new SyncSingleResponseHandler(
                    shopOpenHelper,
                    JdbcFactory.getConverter(localTable),
                    localTable,
                    serverLastTimestamp
            );

            processResponse(makeRequest(api, getApp().emailApiKey, credentials, request), localTable, handler, 0);

        } catch (Exception e) {
            Logger.e("downloadDataTable", e);
            e.printStackTrace();
        }
        return false;
    }
}
